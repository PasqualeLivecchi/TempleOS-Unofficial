<!DOCTYPE HTML>
<html style="background-color:#FFFFFF;">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=US-ASCII">
<title>The Temple Operating System</title>
<meta name="keywords" content="Operating System,64-Bit,64 Bit,Temple,OS,TempleOS,Free,Open Source,Public Domain,x86_64">
<meta name="generator" content="TempleOS (U) V5.04">
<style type="text/css">
.cB0{color:#000000;background-color:#55ffff;}
.cB1{color:#0000aa;background-color:#55ffff;}
.cB2{color:#00aa00;background-color:#55ffff;}
.cB3{color:#00aaaa;background-color:#55ffff;}
.cB5{color:#aa00aa;background-color:#55ffff;}
.cB6{color:#aa5500;background-color:#55ffff;}
.cB7{color:#aaaaaa;background-color:#55ffff;}
.cB9{color:#5555ff;background-color:#55ffff;}
.cBB{color:#55ffff;background-color:#55ffff;}
.cF0{color:#000000;background-color:#ffffff;}
.cF1{color:#0000aa;background-color:#ffffff;}
.cF2{color:#00aa00;background-color:#ffffff;}
.cF3{color:#00aaaa;background-color:#ffffff;}
.cF4{color:#aa0000;background-color:#ffffff;}
.cF5{color:#aa00aa;background-color:#ffffff;}
.cF6{color:#aa5500;background-color:#ffffff;}
.cF7{color:#aaaaaa;background-color:#ffffff;}
.cF8{color:#555555;background-color:#ffffff;}
.cF9{color:#5555ff;background-color:#ffffff;}
.cFA{color:#55ff55;background-color:#ffffff;}
.cFB{color:#55ffff;background-color:#ffffff;}
.cFC{color:#ff5555;background-color:#ffffff;}
.cFD{color:#ff55ff;background-color:#ffffff;}
.cFE{color:#ffff55;background-color:#ffffff;}
.cFF{color:#ffffff;background-color:#ffffff;}
</style>
</head>
<body style="background-color:#55FFFF; border-style:solid;
	  border-width:8px; border-color:#0000AA;
	  margin-left:auto; margin-right:auto; width:800px; ">
<pre style="font-family:courier;font-size:10pt">
<div style="margin-left:auto; margin-right:auto; width: 640px;">
<a name="l1"></a><span class=cB1>public</span><span class=cB0> </span><span class=cB1>class</span><span class=cB0> CGrVectMap
<a name="l2"></a>{
<a name="l3"></a>  </span><span class=cB1>U0</span><span class=cB0> </span><span class=cB1>start</span><span class=cB0>;
<a name="l4"></a>  </span><span class=cB9>I32</span><span class=cB0> width,height;
<a name="l5"></a>  </span><span class=cB1>U8</span><span class=cB0> r_bits,poly_line_cnt_bits,pad,pad;
<a name="l6"></a>  </span><span class=cB9>U32</span><span class=cB0> rect_cnt;
<a name="l7"></a>  </span><span class=cB1>U0</span><span class=cB0> </span><span class=cB1>end</span><span class=cB0>;
<a name="l8"></a>
<a name="l9"></a>  </span><span class=cB9>CColorROPU32</span><span class=cB0> bkcolor,pad;
<a name="l10"></a>
<a name="l11"></a>  </span><span class=cB2>//Array of bit numbers for rectangle starts</span><span class=cB0>
<a name="l12"></a>  </span><span class=cB2>//Can be regenerated with VectMapRectStartBits()</span><span class=cB0>
<a name="l13"></a>  </span><span class=cB9>U32</span><span class=cB0> *rect_start_bits;
<a name="l14"></a>
<a name="l15"></a>  </span><span class=cB1>U8</span><span class=cB0> *body;
<a name="l16"></a>};
<a name="l17"></a>
<a name="l18"></a>#</span><span class=cB1>help_index</span><span class=cB0> </span><span class=cB6>&quot;Graphics/CGrVectMap&quot;</span><span class=cB0>
<a name="l19"></a></span><span class=cB2>/*</span><span class=cB0>
<a name="l20"></a></span><span class=cB2>This processes a monocrome map, finds edges and generates vect graphic</span><span class=cB0>
<a name="l21"></a></span><span class=cB2>representations of the map broken into small rectangles.  The rectangles</span><span class=cB0>
<a name="l22"></a></span><span class=cB2>are encoded a bit-oriented structure.</span><span class=cB0>
<a name="l23"></a>
<a name="l24"></a></span><span class=cB2>PolyLineStruct {</span><span class=cB0>
<a name="l25"></a></span><span class=cB2>1 Bit</span><span class=cB0>   </span><span class=cB2>  : set is valid polyline, clear is end of polyline lst</span><span class=cB0>
<a name="l26"></a></span><span class=cB2>(R_BITS)  : X-coordinate of polyline start</span><span class=cB0>
<a name="l27"></a></span><span class=cB2>(R_BITS)  : Y-coordinate of polyline start</span><span class=cB0>
<a name="l28"></a></span><span class=cB2>(poly_line_cnt_bits): Number of polyline direction entries</span><span class=cB0>
<a name="l29"></a></span><span class=cB2>N*3  : N-long seq of 1 pixel directional movements</span><span class=cB0>
<a name="l30"></a></span><span class=cB2>}</span><span class=cB0>
<a name="l31"></a>
<a name="l32"></a></span><span class=cB2>FloodFillStruct {</span><span class=cB0>
<a name="l33"></a></span><span class=cB2>1 Bit</span><span class=cB0>   </span><span class=cB2>  : set is valid flood fill entry, clear is end of floodfill lst</span><span class=cB0>
<a name="l34"></a></span><span class=cB2>(1+R_BITS): X-coordinate*2 of flood fill (half pixels)</span><span class=cB0>
<a name="l35"></a></span><span class=cB2>(1+R_BITS): Y-coordinate*2 of flood fill (half pixels)</span><span class=cB0>
<a name="l36"></a></span><span class=cB2>}</span><span class=cB0>
<a name="l37"></a>
<a name="l38"></a></span><span class=cB2>Rect {</span><span class=cB0>
<a name="l39"></a></span><span class=cB2>1 Bit</span><span class=cB0>   </span><span class=cB2>  : set is valid rectangle entry, clear is end of rectangle lst</span><span class=cB0>
<a name="l40"></a></span><span class=cB2>PolyLineStructLst</span><span class=cB0>
<a name="l41"></a></span><span class=cB2>FloodFillStructLst</span><span class=cB0>
<a name="l42"></a></span><span class=cB2>}</span><span class=cB0>
<a name="l43"></a></span><span class=cB2>*/</span><span class=cB0>
<a name="l44"></a>
<a name="l45"></a>#</span><span class=cB1>define</span><span class=cB0> R_BITS          6
<a name="l46"></a>#</span><span class=cB1>define</span><span class=cB0> R_BORDER        1
<a name="l47"></a>#</span><span class=cB1>define</span><span class=cB0> R_WIDTH         (1&lt;&lt;R_BITS-2*R_BORDER)
<a name="l48"></a>#</span><span class=cB1>define</span><span class=cB0> R_HEIGHT        (1&lt;&lt;R_BITS-2*R_BORDER)
<a name="l49"></a>
<a name="l50"></a></span><span class=cB1>U0</span><span class=cB0> VectMapBlotRect(</span><span class=cB9>CDC</span><span class=cB0> *dc,CGrVectMap *vm,</span><span class=cB9>I64</span><span class=cB0> bit,</span><span class=cB1>F64</span><span class=cB0> scale)
<a name="l51"></a>{
<a name="l52"></a>  </span><span class=cB9>I64</span><span class=cB0> k,cnt,i0,j0,i,j,rect_dft,not_rect_dft;
<a name="l53"></a>  </span><span class=cB1>U8</span><span class=cB0> *body=vm-&gt;body;
<a name="l54"></a>  </span><span class=cB1>F64</span><span class=cB0> d=scale/2;
<a name="l55"></a>  dc-&gt;thick=scale+0.5;
<a name="l56"></a>  dc-&gt;color=rect_dft=</span><span class=cB5>Bt</span><span class=cB0>(body,bit++);
<a name="l57"></a>  not_rect_dft=1-rect_dft;
<a name="l58"></a>
<a name="l59"></a>  dc-&gt;bkcolor=vm-&gt;bkcolor;
<a name="l60"></a>  </span><span class=cB5>GrRect</span><span class=cB0>(dc,0,0,dc-&gt;width,dc-&gt;height);
<a name="l61"></a>
<a name="l62"></a>  dc-&gt;color=not_rect_dft;
<a name="l63"></a>  </span><span class=cB1>while</span><span class=cB0> (</span><span class=cB5>Bt</span><span class=cB7>(</span><span class=cB0>body,bit++</span><span class=cB7>)</span><span class=cB0>) </span><span class=cB7>{</span><span class=cB0>
<a name="l64"></a>    j=</span><span class=cB5>BFieldExtU32</span><span class=cB0>(body,bit,R_BITS);
<a name="l65"></a>    bit+=R_BITS;
<a name="l66"></a>    i=</span><span class=cB5>BFieldExtU32</span><span class=cB0>(body,bit,R_BITS);
<a name="l67"></a>    bit+=R_BITS;
<a name="l68"></a>    cnt=</span><span class=cB5>BFieldExtU32</span><span class=cB0>(body,bit,vm-&gt;poly_line_cnt_bits);
<a name="l69"></a>    bit+=vm-&gt;poly_line_cnt_bits;
<a name="l70"></a>    </span><span class=cB1>if</span><span class=cB0> (!cnt)
<a name="l71"></a>      </span><span class=cB5>GrPlot3</span><span class=cB0>(dc,</span><span class=cB7>(</span><span class=cB0>j-R_BORDER</span><span class=cB7>)</span><span class=cB0>*scale+d,</span><span class=cB7>(</span><span class=cB0>i-R_BORDER</span><span class=cB7>)</span><span class=cB0>*scale+d,0);
<a name="l72"></a>    </span><span class=cB1>else</span><span class=cB0> {
<a name="l73"></a>      i0=i;j0=j;
<a name="l74"></a>      </span><span class=cB1>while</span><span class=cB0> (cnt--) </span><span class=cB7>{</span><span class=cB0>
<a name="l75"></a>        k=</span><span class=cB5>BFieldExtU32</span><span class=cB0>(body,bit,3);
<a name="l76"></a>        bit+=3;
<a name="l77"></a>        i+=</span><span class=cBB>gr_y_offsets</span><span class=cB0>[k];
<a name="l78"></a>        j+=</span><span class=cBB>gr_x_offsets</span><span class=cB0>[k];
<a name="l79"></a>        </span><span class=cB5>GrLine3</span><span class=cB0>(dc,</span><span class=cB7>(</span><span class=cB0>j0-R_BORDER</span><span class=cB7>)</span><span class=cB0>*scale+d,</span><span class=cB7>(</span><span class=cB0>i0-R_BORDER</span><span class=cB7>)</span><span class=cB0>*scale+d,0,
<a name="l80"></a>              </span><span class=cB7>(</span><span class=cB0>j-R_BORDER</span><span class=cB7>)</span><span class=cB0>*scale+d,</span><span class=cB7>(</span><span class=cB0>i-R_BORDER</span><span class=cB7>)</span><span class=cB0>*scale+d,0);
<a name="l81"></a>        i0=i; j0=j;
<a name="l82"></a>      </span><span class=cB7>}</span><span class=cB0>
<a name="l83"></a>    }
<a name="l84"></a>  </span><span class=cB7>}</span><span class=cB0>
<a name="l85"></a>  </span><span class=cB1>while</span><span class=cB0> (</span><span class=cB5>Bt</span><span class=cB7>(</span><span class=cB0>body,bit++</span><span class=cB7>)</span><span class=cB0>) </span><span class=cB7>{</span><span class=cB0>
<a name="l86"></a>    j=</span><span class=cB5>BFieldExtU32</span><span class=cB0>(body,bit,R_BITS+1);
<a name="l87"></a>    bit+=R_BITS+1;
<a name="l88"></a>    i=</span><span class=cB5>BFieldExtU32</span><span class=cB0>(body,bit,R_BITS+1);
<a name="l89"></a>    bit+=R_BITS+1;
<a name="l90"></a>    </span><span class=cB1>if</span><span class=cB0> (</span><span class=cB5>GrPeek</span><span class=cB7>(</span><span class=cB0>dc,(j/2.0-R_BORDER)*scale+d,(i/2.0-R_BORDER)*scale+d</span><span class=cB7>)</span><span class=cB0>==rect_dft)
<a name="l91"></a>      </span><span class=cB5>GrFloodFill</span><span class=cB0>(dc,</span><span class=cB7>(</span><span class=cB0>j/2.0-R_BORDER</span><span class=cB7>)</span><span class=cB0>*scale+d,</span><span class=cB7>(</span><span class=cB0>i/2.0-R_BORDER</span><span class=cB7>)</span><span class=cB0>*scale+d);
<a name="l92"></a>  </span><span class=cB7>}</span><span class=cB0>
<a name="l93"></a>}
<a name="l94"></a>
<a name="l95"></a></span><span class=cB1>class</span><span class=cB0> CMPVMBlot
<a name="l96"></a>{
<a name="l97"></a>  </span><span class=cB9>CDC</span><span class=cB0> *dc,*rect_dc;
<a name="l98"></a>  CGrVectMap *vm;
<a name="l99"></a>  </span><span class=cB9>I64</span><span class=cB0> bit;
<a name="l100"></a>  </span><span class=cB9>I64</span><span class=cB0> xx,yy;
<a name="l101"></a>  </span><span class=cB1>F64</span><span class=cB0> scale;
<a name="l102"></a>  </span><span class=cB9>I64</span><span class=cB0> busy;
<a name="l103"></a>};
<a name="l104"></a>
<a name="l105"></a>
<a name="l106"></a></span><span class=cB1>U0</span><span class=cB0> VectMapBlotRectMP(CMPVMBlot *mp)
<a name="l107"></a>{
<a name="l108"></a>  VectMapBlotRect(mp-&gt;rect_dc,mp-&gt;vm,mp-&gt;bit,mp-&gt;scale);
<a name="l109"></a>  </span><span class=cB5>GrBlot</span><span class=cB0>(mp-&gt;dc,mp-&gt;xx,mp-&gt;yy,mp-&gt;rect_dc);
<a name="l110"></a>  mp-&gt;busy=</span><span class=cB3>FALSE</span><span class=cB0>;
<a name="l111"></a>}
<a name="l112"></a>
<a name="l113"></a>
<a name="l114"></a></span><span class=cB1>public</span><span class=cB0> </span><span class=cB1>U0</span><span class=cB0> VectMapBlotMP(</span><span class=cB9>CDC</span><span class=cB0> *dc,</span><span class=cB9>I64</span><span class=cB0> x,</span><span class=cB9>I64</span><span class=cB0> y,CGrVectMap *vm,
<a name="l115"></a>        </span><span class=cB1>F64</span><span class=cB0> scale=1.0,</span><span class=cB9>I64</span><span class=cB0> _mp_cnt=0)
<a name="l116"></a>{
<a name="l117"></a>  </span><span class=cB9>I64</span><span class=cB0> i,i_lo,i_hi,j,j_lo,j_hi,k,cpu,pass,
<a name="l118"></a>        w=(vm-&gt;width +R_WIDTH-1)/R_WIDTH,
<a name="l119"></a>        h=(vm-&gt;height+R_HEIGHT-1)/R_HEIGHT;
<a name="l120"></a>  </span><span class=cB1>F64</span><span class=cB0> xx,yy,r_scale=scale*(R_WIDTH+1.0/scale)/R_WIDTH;
<a name="l121"></a>  CMPVMBlot *mp;
<a name="l122"></a>  </span><span class=cB1>if</span><span class=cB0> (!dc || !vm) </span><span class=cB1>return</span><span class=cB0>;
<a name="l123"></a>  </span><span class=cB1>if</span><span class=cB0> (</span><span class=cB5>Gs</span><span class=cB0>-&gt;num)
<a name="l124"></a>    _mp_cnt=1; </span><span class=cB2>//Only core #0 can be master</span><span class=cB0>
<a name="l125"></a>  </span><span class=cB1>else</span><span class=cB0> </span><span class=cB1>if</span><span class=cB0> (!_mp_cnt)
<a name="l126"></a>    _mp_cnt=</span><span class=cBB>mp_cnt</span><span class=cB0>;
<a name="l127"></a>  </span><span class=cB1>else</span><span class=cB0> </span><span class=cB1>if</span><span class=cB0> (_mp_cnt&gt;</span><span class=cBB>mp_cnt</span><span class=cB0>)
<a name="l128"></a>    _mp_cnt=</span><span class=cBB>mp_cnt</span><span class=cB0>;
<a name="l129"></a>  cpu=_mp_cnt-1;
<a name="l130"></a>
<a name="l131"></a>  mp=</span><span class=cB5>MAlloc</span><span class=cB0>(_mp_cnt*</span><span class=cB1>sizeof</span><span class=cB7>(</span><span class=cB0>CMPVMBlot</span><span class=cB7>)</span><span class=cB0>);
<a name="l132"></a>
<a name="l133"></a>  </span><span class=cB1>for</span><span class=cB0> (i=0;i&lt;_mp_cnt;i++) </span><span class=cB7>{</span><span class=cB0>
<a name="l134"></a>    mp[i].rect_dc=</span><span class=cB5>DCNew</span><span class=cB0>(R_WIDTH*r_scale,R_HEIGHT*r_scale,</span><span class=cB5>Fs</span><span class=cB0>);
<a name="l135"></a>    mp[i].dc=</span><span class=cB5>DCAlias</span><span class=cB0>(dc,dc-&gt;win_task);
<a name="l136"></a>    mp[i].dc-&gt;color=dc-&gt;color;
<a name="l137"></a>    mp[i].vm=vm;
<a name="l138"></a>    mp[i].scale=r_scale;
<a name="l139"></a>    mp[i].busy=</span><span class=cB3>FALSE</span><span class=cB0>;
<a name="l140"></a>  </span><span class=cB7>}</span><span class=cB0>
<a name="l141"></a>
<a name="l142"></a>  </span><span class=cB1>if</span><span class=cB0> (y&lt;0)
<a name="l143"></a>    i_lo=-y/(R_HEIGHT*scale);
<a name="l144"></a>  </span><span class=cB1>else</span><span class=cB0>
<a name="l145"></a>    i_lo=0;
<a name="l146"></a>  </span><span class=cB1>if</span><span class=cB0> (R_HEIGHT*scale*h+y&gt;dc-&gt;height)
<a name="l147"></a>    i_hi=</span><span class=cB5>MinI64</span><span class=cB0>(</span><span class=cB7>(</span><span class=cB0>dc-&gt;height-y</span><span class=cB7>)</span><span class=cB0>/</span><span class=cB7>(</span><span class=cB0>R_HEIGHT*scale</span><span class=cB7>)</span><span class=cB0>+1,h);
<a name="l148"></a>  </span><span class=cB1>else</span><span class=cB0>
<a name="l149"></a>    i_hi=h;
<a name="l150"></a>
<a name="l151"></a>  </span><span class=cB1>if</span><span class=cB0> (x&lt;0)
<a name="l152"></a>    j_lo=-x/(R_WIDTH*scale);
<a name="l153"></a>  </span><span class=cB1>else</span><span class=cB0>
<a name="l154"></a>    j_lo=0;
<a name="l155"></a>  </span><span class=cB1>if</span><span class=cB0> (R_WIDTH*scale*w+x&gt;dc-&gt;width)
<a name="l156"></a>    j_hi=</span><span class=cB5>MinI64</span><span class=cB0>(</span><span class=cB7>(</span><span class=cB0>dc-&gt;width-x</span><span class=cB7>)</span><span class=cB0>/</span><span class=cB7>(</span><span class=cB0>R_WIDTH*scale</span><span class=cB7>)</span><span class=cB0>+1,w);
<a name="l157"></a>  </span><span class=cB1>else</span><span class=cB0>
<a name="l158"></a>    j_hi=w;
<a name="l159"></a>
<a name="l160"></a>  xx=x+j_lo*R_WIDTH*scale;
<a name="l161"></a>  </span><span class=cB1>for</span><span class=cB0> (j=j_lo;j&lt;j_hi;j++) </span><span class=cB7>{</span><span class=cB0>
<a name="l162"></a>    yy=y+i_lo*R_WIDTH*scale;
<a name="l163"></a>    k=i_lo*w+j;
<a name="l164"></a>    </span><span class=cB1>for</span><span class=cB0> (i=i_lo;i&lt;i_hi;i++) {
<a name="l165"></a>      </span><span class=cB1>if</span><span class=cB0> (_mp_cnt&gt;1) </span><span class=cB7>{</span><span class=cB0>
<a name="l166"></a>        pass=0;
<a name="l167"></a></span><span class=cB2>//Does up to two passes</span><span class=cB0>
<a name="l168"></a>        </span><span class=cB1>while</span><span class=cB0> (</span><span class=cB3>TRUE</span><span class=cB0>)
<a name="l169"></a>          </span><span class=cB1>if</span><span class=cB0> (!pass &amp;&amp; !cpu) {
<a name="l170"></a>            pass++;
<a name="l171"></a>            cpu=_mp_cnt-1;
<a name="l172"></a>          } </span><span class=cB1>else</span><span class=cB0> </span><span class=cB1>if</span><span class=cB0> (mp[cpu].busy) </span><span class=cB2>//by the way, core #0 is never busy</span><span class=cB0>
<a name="l173"></a>            cpu--;
<a name="l174"></a>          </span><span class=cB1>else</span><span class=cB0>
<a name="l175"></a>            </span><span class=cB1>break</span><span class=cB0>;
<a name="l176"></a>      </span><span class=cB7>}</span><span class=cB0>
<a name="l177"></a>      mp[cpu].xx=xx;
<a name="l178"></a>      mp[cpu].yy=yy;
<a name="l179"></a>      mp[cpu].bit=vm-&gt;rect_start_bits[k];
<a name="l180"></a>      </span><span class=cB1>if</span><span class=cB0> (!cpu)
<a name="l181"></a>        VectMapBlotRectMP(mp);
<a name="l182"></a>      </span><span class=cB1>else</span><span class=cB0> </span><span class=cB7>{</span><span class=cB0>
<a name="l183"></a>        mp[cpu].busy=</span><span class=cB3>TRUE</span><span class=cB0>;
<a name="l184"></a>        </span><span class=cB5>JobQue</span><span class=cB0>(&amp;VectMapBlotRectMP,&amp;mp[cpu],cpu);
<a name="l185"></a>      </span><span class=cB7>}</span><span class=cB0>
<a name="l186"></a>      k+=w;
<a name="l187"></a>      yy+=R_HEIGHT*scale;
<a name="l188"></a>    }
<a name="l189"></a>    xx+=R_WIDTH*scale;
<a name="l190"></a>  </span><span class=cB7>}</span><span class=cB0>
<a name="l191"></a>  </span><span class=cB1>for</span><span class=cB0> (i=_mp_cnt-1;i&gt;=0;i--) </span><span class=cB7>{</span><span class=cB0>
<a name="l192"></a>    </span><span class=cB1>while</span><span class=cB0>(mp[i].busy)
<a name="l193"></a>      </span><span class=cB5>Yield</span><span class=cB0>;
<a name="l194"></a>    </span><span class=cB5>DCDel</span><span class=cB0>(mp[i].rect_dc);
<a name="l195"></a>    </span><span class=cB5>DCDel</span><span class=cB0>(mp[i].dc);
<a name="l196"></a>  </span><span class=cB7>}</span><span class=cB0>
<a name="l197"></a>  </span><span class=cB5>Free</span><span class=cB0>(mp);
<a name="l198"></a>}
<a name="l199"></a>
<a name="l200"></a></span><span class=cB1>Bool</span><span class=cB0> IsSolidSquare(</span><span class=cB9>CDC</span><span class=cB0> *dc,</span><span class=cB9>I64</span><span class=cB0> x,</span><span class=cB9>I64</span><span class=cB0> y,</span><span class=cB9>I64</span><span class=cB0> edge,</span><span class=cB9>CColorROPU32</span><span class=cB0> color)
<a name="l201"></a>{
<a name="l202"></a>  </span><span class=cB9>I64</span><span class=cB0> i,j;
<a name="l203"></a>  edge&gt;&gt;=1;
<a name="l204"></a>  </span><span class=cB1>for</span><span class=cB0> (i=-edge;i&lt;edge;i++)
<a name="l205"></a>    </span><span class=cB1>for</span><span class=cB0> (j=-edge;j&lt;edge;j++)
<a name="l206"></a>      </span><span class=cB1>if</span><span class=cB0> (</span><span class=cB5>GrPeek</span><span class=cB7>(</span><span class=cB0>dc,x+j,y+i</span><span class=cB7>)</span><span class=cB0>!=color)
<a name="l207"></a>        </span><span class=cB1>return</span><span class=cB0> </span><span class=cB3>FALSE</span><span class=cB0>;
<a name="l208"></a>  </span><span class=cB1>return</span><span class=cB0> </span><span class=cB3>TRUE</span><span class=cB0>;
<a name="l209"></a>}
<a name="l210"></a>
<a name="l211"></a></span><span class=cB9>I64</span><span class=cB0> VectizeRect(</span><span class=cB9>CDC</span><span class=cB0> *dc,</span><span class=cB9>I64</span><span class=cB0> _x,</span><span class=cB9>I64</span><span class=cB0> _y,CGrVectMap *vm,</span><span class=cB9>I64</span><span class=cB0> _bit,
<a name="l212"></a>  </span><span class=cB9>I64</span><span class=cB0> poly_line_cnt_bits,</span><span class=cB9>I64</span><span class=cB0> *_max_poly_line_cnt_bits)
<a name="l213"></a>{ </span><span class=cB2>//Returns number of bits to represent rect</span><span class=cB0>
<a name="l214"></a>  </span><span class=cB9>CDC</span><span class=cB0> *b_desired=</span><span class=cB5>DCExt</span><span class=cB0>(dc,_x-R_BORDER,_y-R_BORDER,
<a name="l215"></a>        _x+R_WIDTH+R_BORDER*2-1,_y+R_BORDER*2+R_HEIGHT-1),
<a name="l216"></a>        *b_edge=</span><span class=cB5>DCNew</span><span class=cB0>(R_WIDTH+R_BORDER*2,R_HEIGHT+R_BORDER*2,</span><span class=cB5>Fs</span><span class=cB0>),
<a name="l217"></a>        *b_actual,
<a name="l218"></a>        *b_link_check=</span><span class=cB5>DCNew</span><span class=cB0>(R_WIDTH+R_BORDER*2,R_HEIGHT+R_BORDER*2,</span><span class=cB5>Fs</span><span class=cB0>);
<a name="l219"></a>  </span><span class=cB9>I64</span><span class=cB0> step,step_bits,x,y,xx,yy,xx1,yy1,xx2,yy2,cnt=0,k,kk,rect_dft,not_rect_dft,
<a name="l220"></a>        cnt_bit,link_bit1,link_bit2,link_bit_limit,bit=_bit,
<a name="l221"></a>        max_poly_line_cnt_bits;
<a name="l222"></a>  </span><span class=cB1>U8</span><span class=cB0> *body=vm-&gt;body;
<a name="l223"></a>  </span><span class=cB1>Bool</span><span class=cB0> found;
<a name="l224"></a>  </span><span class=cB1>if</span><span class=cB0> (_max_poly_line_cnt_bits)
<a name="l225"></a>    max_poly_line_cnt_bits=*_max_poly_line_cnt_bits;
<a name="l226"></a>  </span><span class=cB1>else</span><span class=cB0>
<a name="l227"></a>    max_poly_line_cnt_bits=3;
<a name="l228"></a>
<a name="l229"></a>    </span><span class=cB2>//Count ON pixels</span><span class=cB0>
<a name="l230"></a>  </span><span class=cB1>for</span><span class=cB0> (y=0;y&lt;R_HEIGHT;y++)
<a name="l231"></a>    </span><span class=cB1>for</span><span class=cB0> (x=0;x&lt;R_WIDTH;x++)
<a name="l232"></a>      </span><span class=cB1>if</span><span class=cB0> (</span><span class=cB5>GrPeek</span><span class=cB7>(</span><span class=cB0>b_desired,R_BORDER+x,R_BORDER+y</span><span class=cB7>)</span><span class=cB0>==1)
<a name="l233"></a>        cnt++;
<a name="l234"></a>
<a name="l235"></a>  </span><span class=cB1>if</span><span class=cB0> (cnt&gt;=R_WIDTH*R_HEIGHT/2)
<a name="l236"></a>    rect_dft=1;
<a name="l237"></a>  </span><span class=cB1>else</span><span class=cB0>
<a name="l238"></a>    rect_dft=0;
<a name="l239"></a>  not_rect_dft=1-rect_dft;
<a name="l240"></a>
<a name="l241"></a>  </span><span class=cB5>BEqu</span><span class=cB0>(body,bit++,rect_dft);
<a name="l242"></a>
<a name="l243"></a>  </span><span class=cB1>if</span><span class=cB0> (!cnt || cnt==R_WIDTH*R_HEIGHT) </span><span class=cB7>{</span><span class=cB0>
<a name="l244"></a></span><span class=cB2>//Rect is all ON or OFF</span><span class=cB0>
<a name="l245"></a>    </span><span class=cB5>Btr</span><span class=cB0>(body,bit++); </span><span class=cB2>//End of poly-line lst</span><span class=cB0>
<a name="l246"></a>    </span><span class=cB5>Btr</span><span class=cB0>(body,bit++); </span><span class=cB2>//End of flood-fill lst</span><span class=cB0>
<a name="l247"></a>  </span><span class=cB7>}</span><span class=cB0> </span><span class=cB1>else</span><span class=cB0> </span><span class=cB7>{</span><span class=cB0>
<a name="l248"></a>    </span><span class=cB1>for</span><span class=cB0> (y=0;y&lt;R_HEIGHT+R_BORDER*2;y++)
<a name="l249"></a>      </span><span class=cB1>for</span><span class=cB0> (x=0;x&lt;R_WIDTH+R_BORDER*2;x++) {
<a name="l250"></a>        b_edge-&gt;color=0;
<a name="l251"></a>        </span><span class=cB1>if</span><span class=cB0> (</span><span class=cB5>GrPeek</span><span class=cB7>(</span><span class=cB0>b_desired,x,y</span><span class=cB7>)</span><span class=cB0>==not_rect_dft)
<a name="l252"></a>          </span><span class=cB1>for</span><span class=cB0> (k=0;k&lt;8;k++)
<a name="l253"></a>            </span><span class=cB1>if</span><span class=cB0> (</span><span class=cB5>GrPeek</span><span class=cB7>(</span><span class=cB0>b_desired,x+</span><span class=cBB>gr_x_offsets</span><span class=cB0>[k],y+</span><span class=cBB>gr_y_offsets</span><span class=cB0>[k]</span><span class=cB7>)</span><span class=cB0>==rect_dft)
<a name="l254"></a>              b_edge-&gt;color=1;
<a name="l255"></a>        </span><span class=cB5>GrPlot</span><span class=cB0>(b_edge,x,y);
<a name="l256"></a>      }
<a name="l257"></a>
<a name="l258"></a>    b_edge-&gt;color=0;
<a name="l259"></a>    link_bit1=bit;
<a name="l260"></a>    </span><span class=cB1>for</span><span class=cB0> (y=0;y&lt;R_HEIGHT+R_BORDER*2;y++)
<a name="l261"></a>      </span><span class=cB1>for</span><span class=cB0> (x=0;x&lt;R_WIDTH+R_BORDER*2;x++)
<a name="l262"></a>        </span><span class=cB1>if</span><span class=cB0> (</span><span class=cB5>GrPeek</span><span class=cB7>(</span><span class=cB0>b_edge,x,y</span><span class=cB7>)</span><span class=cB0>==1) {
<a name="l263"></a>          </span><span class=cB5>Bts</span><span class=cB0>(body,bit++); </span><span class=cB2>//Show not end of poly-line lst</span><span class=cB0>
<a name="l264"></a>          </span><span class=cB5>GrPlot</span><span class=cB0>(b_edge,x,y);
<a name="l265"></a>          </span><span class=cB5>BFieldOrU32</span><span class=cB0>(body,bit,x); </span><span class=cB2>//Poly-line starting X coordinate in rect</span><span class=cB0>
<a name="l266"></a>          bit+=R_BITS;
<a name="l267"></a>          </span><span class=cB5>BFieldOrU32</span><span class=cB0>(body,bit,y); </span><span class=cB2>//Poly-line starting Y coordinate in rect</span><span class=cB0>
<a name="l268"></a>          bit+=R_BITS;
<a name="l269"></a>          yy=y; xx=x;
<a name="l270"></a>          cnt_bit=bit;
<a name="l271"></a>          bit+=poly_line_cnt_bits; </span><span class=cB2>//Reserve for cnt of dir offsets in poly-line</span><span class=cB0>
<a name="l272"></a>          cnt=0;
<a name="l273"></a>          </span><span class=cB1>do</span><span class=cB0> </span><span class=cB7>{</span><span class=cB0>
<a name="l274"></a>            found=</span><span class=cB3>FALSE</span><span class=cB0>;
<a name="l275"></a>            </span><span class=cB1>for</span><span class=cB0> (k=0;k&lt;8;k++) {
<a name="l276"></a>              yy2=yy+</span><span class=cBB>gr_y_offsets</span><span class=cB0>[k];
<a name="l277"></a>              xx2=xx+</span><span class=cBB>gr_x_offsets</span><span class=cB0>[k];
<a name="l278"></a>              </span><span class=cB1>if</span><span class=cB0> (0&lt;=xx2&lt;R_WIDTH+R_BORDER*2 &amp;&amp; 0&lt;=yy2&lt;R_HEIGHT+R_BORDER*2 &amp;&amp;
<a name="l279"></a>                    </span><span class=cB5>GrPeek</span><span class=cB7>(</span><span class=cB0>b_edge,xx2,yy2</span><span class=cB7>)</span><span class=cB0>==1) </span><span class=cB7>{</span><span class=cB0>
<a name="l280"></a>                cnt++;
<a name="l281"></a>                </span><span class=cB5>BFieldOrU32</span><span class=cB0>(body,bit,k); </span><span class=cB2>//3-bit (or 2) coding of dir movement</span><span class=cB0>
<a name="l282"></a>                bit+=3;
<a name="l283"></a>                </span><span class=cB5>GrPlot</span><span class=cB0>(b_edge,xx2,yy2);
<a name="l284"></a>                yy=yy2; xx=xx2;
<a name="l285"></a>                found=</span><span class=cB3>TRUE</span><span class=cB0>;
<a name="l286"></a>                </span><span class=cB1>break</span><span class=cB0>;
<a name="l287"></a>              </span><span class=cB7>}</span><span class=cB0>
<a name="l288"></a>            }
<a name="l289"></a>          </span><span class=cB7>}</span><span class=cB0> </span><span class=cB1>while</span><span class=cB0> (found);
<a name="l290"></a>          </span><span class=cB5>BFieldOrU32</span><span class=cB0>(body,cnt_bit,cnt);
<a name="l291"></a>          </span><span class=cB1>if</span><span class=cB0> (cnt &amp;&amp; </span><span class=cB5>Bsr</span><span class=cB7>(</span><span class=cB0>cnt</span><span class=cB7>)</span><span class=cB0>+1&gt;max_poly_line_cnt_bits)
<a name="l292"></a>            max_poly_line_cnt_bits=</span><span class=cB5>Bsr</span><span class=cB0>(cnt)+1;
<a name="l293"></a>        }
<a name="l294"></a>
<a name="l295"></a>        </span><span class=cB2>//Connect adjacent groups with link to prevent flood-fill leaks.</span><span class=cB0>
<a name="l296"></a>    link_bit_limit=bit;
<a name="l297"></a>    </span><span class=cB1>while</span><span class=cB0> (link_bit1&lt;link_bit_limit) {
<a name="l298"></a>      link_bit1++;
<a name="l299"></a>      x=</span><span class=cB5>BFieldExtU32</span><span class=cB0>(body,link_bit1,R_BITS);
<a name="l300"></a>      link_bit1+=R_BITS;
<a name="l301"></a>      y=</span><span class=cB5>BFieldExtU32</span><span class=cB0>(body,link_bit1,R_BITS);
<a name="l302"></a>      link_bit1+=R_BITS;
<a name="l303"></a>
<a name="l304"></a>      link_bit2=link_bit1;
<a name="l305"></a>      yy=y;xx=x;
<a name="l306"></a>      cnt=</span><span class=cB5>BFieldExtU32</span><span class=cB0>(body,link_bit2,poly_line_cnt_bits);
<a name="l307"></a>      link_bit2+=poly_line_cnt_bits;
<a name="l308"></a>      </span><span class=cB1>while</span><span class=cB0> (</span><span class=cB3>TRUE</span><span class=cB0>) </span><span class=cB7>{</span><span class=cB0>
<a name="l309"></a>        </span><span class=cB1>for</span><span class=cB0> (k=0;k&lt;8;k++) {
<a name="l310"></a>          yy2=yy+</span><span class=cBB>gr_y_offsets</span><span class=cB0>[k];
<a name="l311"></a>          xx2=xx+</span><span class=cBB>gr_x_offsets</span><span class=cB0>[k];
<a name="l312"></a>          </span><span class=cB1>if</span><span class=cB0> (0&lt;=xx2&lt;R_WIDTH+R_BORDER*2 &amp;&amp;
<a name="l313"></a>                0&lt;=yy2&lt;R_HEIGHT+R_BORDER*2 &amp;&amp;
<a name="l314"></a>                </span><span class=cB5>GrPeek</span><span class=cB7>(</span><span class=cB0>b_link_check,xx2,yy2</span><span class=cB7>)</span><span class=cB0>==1) </span><span class=cB7>{</span><span class=cB0>
<a name="l315"></a>            </span><span class=cB5>Bts</span><span class=cB0>(body,bit++);
<a name="l316"></a>            </span><span class=cB5>BFieldOrU32</span><span class=cB0>(body,bit,xx);
<a name="l317"></a>            bit+=R_BITS;
<a name="l318"></a>            </span><span class=cB5>BFieldOrU32</span><span class=cB0>(body,bit,yy);
<a name="l319"></a>            bit+=R_BITS;
<a name="l320"></a>            </span><span class=cB5>BFieldOrU32</span><span class=cB0>(body,bit,1);
<a name="l321"></a>            bit+=poly_line_cnt_bits;
<a name="l322"></a>            </span><span class=cB5>BFieldOrU32</span><span class=cB0>(body,bit,k);
<a name="l323"></a>            bit+=3;
<a name="l324"></a>          </span><span class=cB7>}</span><span class=cB0>
<a name="l325"></a>        }
<a name="l326"></a>        </span><span class=cB1>if</span><span class=cB0> (!cnt--)
<a name="l327"></a>          </span><span class=cB1>break</span><span class=cB0>;
<a name="l328"></a>        kk=</span><span class=cB5>BFieldExtU32</span><span class=cB0>(body,link_bit2,3);
<a name="l329"></a>        link_bit2+=3;
<a name="l330"></a>        yy+=</span><span class=cBB>gr_y_offsets</span><span class=cB0>[kk];
<a name="l331"></a>        xx+=</span><span class=cBB>gr_x_offsets</span><span class=cB0>[kk];
<a name="l332"></a>      </span><span class=cB7>}</span><span class=cB0>
<a name="l333"></a>
<a name="l334"></a>      link_bit2=link_bit1;
<a name="l335"></a>      yy=y;xx=x;
<a name="l336"></a>      b_link_check-&gt;color=1;
<a name="l337"></a>      </span><span class=cB5>GrPlot</span><span class=cB0>(b_link_check,xx,yy);
<a name="l338"></a>      cnt=</span><span class=cB5>BFieldExtU32</span><span class=cB0>(body,link_bit2,poly_line_cnt_bits);
<a name="l339"></a>      link_bit2+=poly_line_cnt_bits;
<a name="l340"></a>      </span><span class=cB1>while</span><span class=cB0> (cnt--) </span><span class=cB7>{</span><span class=cB0>
<a name="l341"></a>        kk=</span><span class=cB5>BFieldExtU32</span><span class=cB0>(body,link_bit2,3);
<a name="l342"></a>        link_bit2+=3;
<a name="l343"></a>        yy+=</span><span class=cBB>gr_y_offsets</span><span class=cB0>[kk];
<a name="l344"></a>        xx+=</span><span class=cBB>gr_x_offsets</span><span class=cB0>[kk];
<a name="l345"></a>        </span><span class=cB5>GrPlot</span><span class=cB0>(b_link_check,xx,yy);
<a name="l346"></a>      </span><span class=cB7>}</span><span class=cB0>
<a name="l347"></a>
<a name="l348"></a>      link_bit1=link_bit2;
<a name="l349"></a>    }
<a name="l350"></a>    </span><span class=cB5>Btr</span><span class=cB0>(body,bit++); </span><span class=cB2>//End of poly-line lst</span><span class=cB0>
<a name="l351"></a>
<a name="l352"></a>    b_desired-&gt;color=rect_dft;
<a name="l353"></a>    </span><span class=cB5>GrBorder</span><span class=cB0>(b_desired,0,0,R_WIDTH+2*R_BORDER-1,R_HEIGHT+2*R_BORDER-1);
<a name="l354"></a>    </span><span class=cB5>Btr</span><span class=cB0>(body,bit); </span><span class=cB2>//Tmp end of flood-fill lst</span><span class=cB0>
<a name="l355"></a>
<a name="l356"></a>    </span><span class=cB1>for</span><span class=cB0> (step_bits=2;step_bits&gt;=1;step_bits-=1) {
<a name="l357"></a>      step=1&lt;&lt;step_bits;
<a name="l358"></a>      b_actual=</span><span class=cB5>DCNew</span><span class=cB0>(R_WIDTH/step,R_HEIGHT/step,</span><span class=cB5>Fs</span><span class=cB0>);
<a name="l359"></a>      VectMapBlotRect(b_actual,vm,_bit,1.0/step);
<a name="l360"></a>
<a name="l361"></a>      b_actual-&gt;color=not_rect_dft;
<a name="l362"></a>      </span><span class=cB5>GrBorder</span><span class=cB0>(b_actual,0,0,R_WIDTH+2*R_BORDER-1,R_HEIGHT+2*R_BORDER-1);
<a name="l363"></a>
<a name="l364"></a>      </span><span class=cB2>//Flood fill</span><span class=cB0>
<a name="l365"></a>      </span><span class=cB1>for</span><span class=cB0> (y=R_BORDER;y&lt;R_HEIGHT+R_BORDER;y+=step)
<a name="l366"></a>        </span><span class=cB1>for</span><span class=cB0> (x=R_BORDER;x&lt;R_WIDTH+R_BORDER;x+=step)
<a name="l367"></a>          </span><span class=cB1>if</span><span class=cB0> (IsSolidSquare</span><span class=cB7>(</span><span class=cB0>b_desired,x,y,step,not_rect_dft</span><span class=cB7>)</span><span class=cB0> &amp;&amp;
<a name="l368"></a>                </span><span class=cB5>GrPeek</span><span class=cB7>(</span><span class=cB0>b_actual,x&gt;&gt;step_bits,y&gt;&gt;step_bits</span><span class=cB7>)</span><span class=cB0>==rect_dft) </span><span class=cB7>{</span><span class=cB0>
<a name="l369"></a>            </span><span class=cB5>Bts</span><span class=cB0>(body,bit++); </span><span class=cB2>//Show not end of flood-fill lst</span><span class=cB0>
<a name="l370"></a>            yy=y; xx=x;
<a name="l371"></a>            </span><span class=cB1>for</span><span class=cB0> (k=0;k&lt;4;k++) {
<a name="l372"></a>              yy2=yy;
<a name="l373"></a>              </span><span class=cB1>while</span><span class=cB0> (yy2&lt;R_HEIGHT+R_BORDER-1 &amp;&amp;
<a name="l374"></a>                    IsSolidSquare</span><span class=cB7>(</span><span class=cB0>b_desired,xx,yy2,step,not_rect_dft</span><span class=cB7>)</span><span class=cB0> &amp;&amp;
<a name="l375"></a>                    </span><span class=cB5>GrPeek</span><span class=cB7>(</span><span class=cB0>b_actual,xx&gt;&gt;step_bits,yy2&gt;&gt;step_bits</span><span class=cB7>)</span><span class=cB0>==rect_dft)
<a name="l376"></a>                yy2++;
<a name="l377"></a>              </span><span class=cB1>while</span><span class=cB0> (yy&gt;R_BORDER &amp;&amp;
<a name="l378"></a>                    IsSolidSquare</span><span class=cB7>(</span><span class=cB0>b_desired,xx,yy,step,not_rect_dft</span><span class=cB7>)</span><span class=cB0> &amp;&amp;
<a name="l379"></a>                    </span><span class=cB5>GrPeek</span><span class=cB7>(</span><span class=cB0>b_actual,xx&gt;&gt;step_bits,yy&gt;&gt;step_bits</span><span class=cB7>)</span><span class=cB0>==rect_dft)
<a name="l380"></a>                yy--;
<a name="l381"></a>              yy1=yy+yy2;
<a name="l382"></a>              yy=yy1/2;
<a name="l383"></a>
<a name="l384"></a>              xx2=xx;
<a name="l385"></a>              </span><span class=cB1>while</span><span class=cB0> (xx2&lt;R_WIDTH+R_BORDER-1 &amp;&amp;
<a name="l386"></a>                    IsSolidSquare</span><span class=cB7>(</span><span class=cB0>b_desired,xx2,yy,step,not_rect_dft</span><span class=cB7>)</span><span class=cB0> &amp;&amp;
<a name="l387"></a>                    </span><span class=cB5>GrPeek</span><span class=cB7>(</span><span class=cB0>b_actual,xx2&gt;&gt;step_bits,yy&gt;&gt;step_bits</span><span class=cB7>)</span><span class=cB0>==rect_dft)
<a name="l388"></a>                xx2++;
<a name="l389"></a>              </span><span class=cB1>while</span><span class=cB0> (xx&gt;R_BORDER &amp;&amp;
<a name="l390"></a>                    IsSolidSquare</span><span class=cB7>(</span><span class=cB0>b_desired,xx,yy,step,not_rect_dft</span><span class=cB7>)</span><span class=cB0> &amp;&amp;
<a name="l391"></a>                    </span><span class=cB5>GrPeek</span><span class=cB7>(</span><span class=cB0>b_actual,xx&gt;&gt;step_bits,yy&gt;&gt;step_bits</span><span class=cB7>)</span><span class=cB0>==rect_dft)
<a name="l392"></a>                xx--;
<a name="l393"></a>              xx1=xx+xx2;
<a name="l394"></a>              xx=xx1/2;
<a name="l395"></a>
<a name="l396"></a>            }
<a name="l397"></a>            </span><span class=cB5>GrFloodFill</span><span class=cB0>(b_actual,xx&gt;&gt;step_bits,yy&gt;&gt;step_bits);
<a name="l398"></a>            </span><span class=cB5>BFieldOrU32</span><span class=cB0>(body,bit,xx1); </span><span class=cB2>//Flood fill X-coordinate in rect</span><span class=cB0>
<a name="l399"></a>            bit+=R_BITS+1;
<a name="l400"></a>            </span><span class=cB5>BFieldOrU32</span><span class=cB0>(body,bit,yy1); </span><span class=cB2>//Flood fill Y-coordinate in rect</span><span class=cB0>
<a name="l401"></a>            bit+=R_BITS+1;
<a name="l402"></a>          </span><span class=cB7>}</span><span class=cB0>
<a name="l403"></a>      </span><span class=cB5>DCDel</span><span class=cB0>(b_actual);
<a name="l404"></a>      </span><span class=cB5>Btr</span><span class=cB0>(body,bit); </span><span class=cB2>//Tmp end of flood-fill lst</span><span class=cB0>
<a name="l405"></a>    }
<a name="l406"></a>    bit++; </span><span class=cB2>//End of flood-fill lst</span><span class=cB0>
<a name="l407"></a>  </span><span class=cB7>}</span><span class=cB0>
<a name="l408"></a>
<a name="l409"></a>  </span><span class=cB5>DCDel</span><span class=cB0>(b_desired);
<a name="l410"></a>  </span><span class=cB5>DCDel</span><span class=cB0>(b_edge);
<a name="l411"></a>  </span><span class=cB5>DCDel</span><span class=cB0>(b_link_check);
<a name="l412"></a>
<a name="l413"></a>  </span><span class=cB1>if</span><span class=cB0> (_max_poly_line_cnt_bits) *_max_poly_line_cnt_bits=max_poly_line_cnt_bits;
<a name="l414"></a>
<a name="l415"></a>  </span><span class=cB1>return</span><span class=cB0> bit-_bit;
<a name="l416"></a>}
<a name="l417"></a>
<a name="l418"></a>
<a name="l419"></a>#</span><span class=cB1>define</span><span class=cB0> TMP_BODY_SIZE   0x10000
<a name="l420"></a></span><span class=cB1>public</span><span class=cB0> CGrVectMap *DC2VectMap(</span><span class=cB9>CDC</span><span class=cB0> *dc,</span><span class=cB9>CTask</span><span class=cB0> *mem_task=</span><span class=cB3>NULL</span><span class=cB0>,</span><span class=cB9>I64</span><span class=cB0> *_size=</span><span class=cB3>NULL</span><span class=cB0>)
<a name="l421"></a>{ </span><span class=cB2>//Currently does not convert outer 1 pixel border</span><span class=cB0>
<a name="l422"></a>  </span><span class=cB9>I64</span><span class=cB0> i,j,k,cnt,size,
<a name="l423"></a>        w=(dc-&gt;width-R_BORDER*2+R_WIDTH-1)/R_WIDTH,
<a name="l424"></a>        h=(dc-&gt;height-R_BORDER*2+R_HEIGHT-1)/R_HEIGHT,
<a name="l425"></a>        rect_cnt=w*h,poly_line_cnt_bits=12,max_poly_line_cnt_bits=3;
<a name="l426"></a>  </span><span class=cB9>U32</span><span class=cB0> *rect_start_bits;
<a name="l427"></a>  </span><span class=cB1>U8</span><span class=cB0> *body;
<a name="l428"></a>  CGrVectMap *res,tmpv;
<a name="l429"></a>
<a name="l430"></a>  body=</span><span class=cB5>MAlloc</span><span class=cB0>(TMP_BODY_SIZE);
<a name="l431"></a>
<a name="l432"></a>  </span><span class=cB2>//Pass 1: Get max_poly_line_cnt_bits</span><span class=cB0>
<a name="l433"></a>  </span><span class=cB1>for</span><span class=cB0> (i=0;i&lt;h;i++)
<a name="l434"></a>    </span><span class=cB1>for</span><span class=cB0> (j=0;j&lt;w;j++) </span><span class=cB7>{</span><span class=cB0>
<a name="l435"></a>      </span><span class=cB5>MemSet</span><span class=cB0>(&amp;tmpv,0,</span><span class=cB1>sizeof</span><span class=cB7>(</span><span class=cB0>CGrVectMap</span><span class=cB7>)</span><span class=cB0>);
<a name="l436"></a>      </span><span class=cB5>MemSet</span><span class=cB0>(body,0,TMP_BODY_SIZE);
<a name="l437"></a>      tmpv.width =dc-&gt;width-R_BORDER*2;
<a name="l438"></a>      tmpv.height=dc-&gt;height-R_BORDER*2;
<a name="l439"></a>      tmpv.body=body;
<a name="l440"></a>      tmpv.rect_cnt=rect_cnt;
<a name="l441"></a>      tmpv.r_bits=R_BITS;
<a name="l442"></a>      tmpv.poly_line_cnt_bits=poly_line_cnt_bits;
<a name="l443"></a>      VectizeRect(dc,R_BORDER+j*R_WIDTH,R_BORDER+i*R_HEIGHT,
<a name="l444"></a>            &amp;tmpv,0,poly_line_cnt_bits,&amp;max_poly_line_cnt_bits);
<a name="l445"></a>    </span><span class=cB7>}</span><span class=cB0>
<a name="l446"></a>
<a name="l447"></a>    </span><span class=cB2>//Pass 2: Get cnt</span><span class=cB0>
<a name="l448"></a>  poly_line_cnt_bits=max_poly_line_cnt_bits;
<a name="l449"></a>  cnt=0;
<a name="l450"></a>  </span><span class=cB1>for</span><span class=cB0> (i=0;i&lt;h;i++)
<a name="l451"></a>    </span><span class=cB1>for</span><span class=cB0> (j=0;j&lt;w;j++) </span><span class=cB7>{</span><span class=cB0>
<a name="l452"></a>      </span><span class=cB5>MemSet</span><span class=cB0>(&amp;tmpv,0,</span><span class=cB1>sizeof</span><span class=cB7>(</span><span class=cB0>CGrVectMap</span><span class=cB7>)</span><span class=cB0>);
<a name="l453"></a>      </span><span class=cB5>MemSet</span><span class=cB0>(body,0,TMP_BODY_SIZE);
<a name="l454"></a>      tmpv.width =dc-&gt;width-R_BORDER*2;
<a name="l455"></a>      tmpv.height=dc-&gt;height-R_BORDER*2;
<a name="l456"></a>      tmpv.body=body;
<a name="l457"></a>      tmpv.rect_cnt=rect_cnt;
<a name="l458"></a>      tmpv.r_bits=R_BITS;
<a name="l459"></a>      tmpv.poly_line_cnt_bits=poly_line_cnt_bits;
<a name="l460"></a>      cnt+=VectizeRect(dc,R_BORDER+j*R_WIDTH,R_BORDER+i*R_HEIGHT,
<a name="l461"></a>            &amp;tmpv,0,poly_line_cnt_bits,</span><span class=cB3>NULL</span><span class=cB0>);
<a name="l462"></a>    </span><span class=cB7>}</span><span class=cB0>
<a name="l463"></a>  </span><span class=cB5>Free</span><span class=cB0>(body);
<a name="l464"></a>
<a name="l465"></a>  </span><span class=cB2>//Pass 3</span><span class=cB0>
<a name="l466"></a>  size=(cnt+7)/8;
<a name="l467"></a>  res=</span><span class=cB5>CAlloc</span><span class=cB0>(</span><span class=cB1>sizeof</span><span class=cB7>(</span><span class=cB0>CGrVectMap</span><span class=cB7>)</span><span class=cB0>,mem_task);
<a name="l468"></a>  res-&gt;body=</span><span class=cB5>CAlloc</span><span class=cB0>(size,mem_task);
<a name="l469"></a>  rect_start_bits=</span><span class=cB5>MAlloc</span><span class=cB0>(</span><span class=cB7>(</span><span class=cB0>rect_cnt+1</span><span class=cB7>)</span><span class=cB0>*</span><span class=cB1>sizeof</span><span class=cB7>(</span><span class=cB9>U32</span><span class=cB7>)</span><span class=cB0>,mem_task);
<a name="l470"></a>  res-&gt;width =dc-&gt;width-R_BORDER*2;
<a name="l471"></a>  res-&gt;height=dc-&gt;height-R_BORDER*2;
<a name="l472"></a>  res-&gt;rect_cnt=rect_cnt;
<a name="l473"></a>  res-&gt;r_bits=R_BITS;
<a name="l474"></a>  res-&gt;poly_line_cnt_bits=poly_line_cnt_bits;
<a name="l475"></a>  res-&gt;rect_start_bits=rect_start_bits;
<a name="l476"></a>  k=0;
<a name="l477"></a>  cnt=0;
<a name="l478"></a>  </span><span class=cB1>for</span><span class=cB0> (i=0;i&lt;h;i++)
<a name="l479"></a>    </span><span class=cB1>for</span><span class=cB0> (j=0;j&lt;w;j++) </span><span class=cB7>{</span><span class=cB0>
<a name="l480"></a>      rect_start_bits[k++]=cnt;
<a name="l481"></a>      cnt+=VectizeRect(dc,R_BORDER+j*R_WIDTH,R_BORDER+i*R_HEIGHT,
<a name="l482"></a>            res,cnt,poly_line_cnt_bits,</span><span class=cB3>NULL</span><span class=cB0>);
<a name="l483"></a>    </span><span class=cB7>}</span><span class=cB0>
<a name="l484"></a>  rect_start_bits[k]=cnt;
<a name="l485"></a>
<a name="l486"></a>  </span><span class=cB1>if</span><span class=cB0> (_size) *_size=size;
<a name="l487"></a>  </span><span class=cB1>return</span><span class=cB0> res;
<a name="l488"></a>}
<a name="l489"></a>
<a name="l490"></a></span><span class=cB1>public</span><span class=cB0> </span><span class=cB1>U0</span><span class=cB0> VectMapDel(CGrVectMap *vm)
<a name="l491"></a>{
<a name="l492"></a>  </span><span class=cB5>Free</span><span class=cB0>(vm-&gt;rect_start_bits);
<a name="l493"></a>  </span><span class=cB5>Free</span><span class=cB0>(vm-&gt;body);
<a name="l494"></a>  </span><span class=cB5>Free</span><span class=cB0>(vm);
<a name="l495"></a>}
<a name="l496"></a>
<a name="l497"></a></span><span class=cB9>U32</span><span class=cB0> *VectMapRectStartBits(CGrVectMap *vm,</span><span class=cB9>CTask</span><span class=cB0> *mem_task=</span><span class=cB3>NULL</span><span class=cB0>)
<a name="l498"></a>{
<a name="l499"></a>  </span><span class=cB9>I64</span><span class=cB0> k=0,bit=0;
<a name="l500"></a>  </span><span class=cB1>U8</span><span class=cB0> *body=vm-&gt;body;
<a name="l501"></a>  </span><span class=cB9>U32</span><span class=cB0> *res=</span><span class=cB5>MAlloc</span><span class=cB0>(</span><span class=cB7>(</span><span class=cB0>vm-&gt;rect_cnt+1</span><span class=cB7>)</span><span class=cB0>*</span><span class=cB1>sizeof</span><span class=cB7>(</span><span class=cB9>U32</span><span class=cB7>)</span><span class=cB0>,mem_task);
<a name="l502"></a>  </span><span class=cB1>for</span><span class=cB0> (k=0;k&lt;vm-&gt;rect_cnt;k++) </span><span class=cB7>{</span><span class=cB0>
<a name="l503"></a>    res[k]=bit++;
<a name="l504"></a>    </span><span class=cB1>while</span><span class=cB0> (</span><span class=cB5>Bt</span><span class=cB7>(</span><span class=cB0>body,bit++</span><span class=cB7>)</span><span class=cB0>) {
<a name="l505"></a>      bit+=2*R_BITS;
<a name="l506"></a>      bit+=vm-&gt;poly_line_cnt_bits+
<a name="l507"></a>            3*</span><span class=cB5>BFieldExtU32</span><span class=cB0>(body,bit,vm-&gt;poly_line_cnt_bits);
<a name="l508"></a>    }
<a name="l509"></a>    </span><span class=cB1>while</span><span class=cB0> (</span><span class=cB5>Bt</span><span class=cB7>(</span><span class=cB0>body,bit++</span><span class=cB7>)</span><span class=cB0>)
<a name="l510"></a>      bit+=2*(R_BITS+1);
<a name="l511"></a>  </span><span class=cB7>}</span><span class=cB0>
<a name="l512"></a>  res[k]=bit;
<a name="l513"></a>  </span><span class=cB1>return</span><span class=cB0> res;
<a name="l514"></a>}
</span></div></pre></body>
</html>
